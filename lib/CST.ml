(* Generated by ocaml-tree-sitter. *)
(*
   sml grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_213dc3e = Token.t (* pattern [0-9] *)

type primealphanumeric_ident = Token.t

type unit_pat = (Token.t (* "(" *) * Token.t (* ")" *))

type block_comment = Token.t

type real_scon = Token.t

type tok_semi = Token.t

type block_comment_explicit = unit (* blank *)

type pat_dcab316 = Token.t (* pattern [1-9][0-9]* *)

type integer_scon = Token.t

type semgrep_metavariable = Token.t

type tok_comma = Token.t

type tok_pat_6ca5299 = Token.t

type string_scon = Token.t

type tok_bar = Token.t

type line_comment_explicit = unit (* blank *)

type word_scon = Token.t

type symbolic_ident = Token.t

type char_scon = Token.t

type line_comment = Token.t

type anon_choice_COLON_49dafc4 = [
    `COLON of Token.t (* ":" *)
  | `COLONGT of Token.t (* ":>" *)
]

type tyvar = [ `Prim_id of primealphanumeric_ident (*tok*) ]

type alphaalphanumeric_ident = [
    `Semg_meta of semgrep_metavariable (*tok*)
  | `Tok_pat_6ca5299 of tok_pat_6ca5299 (*tok*)
]

type scon = [
    `Int_scon of integer_scon (*tok*)
  | `Word_scon of word_scon (*tok*)
  | `Real_scon of real_scon (*tok*)
  | `Str_scon of string_scon (*tok*)
  | `Char_scon of char_scon (*tok*)
]

type tyvar_ty = tyvar

type strid = [ `Alph_id of alphaalphanumeric_ident ]

type tycon = [
    `Alph_id of alphaalphanumeric_ident
  | `Symb_id of symbolic_ident (*tok*)
]

type fctid = [ `Alph_id of alphaalphanumeric_ident ]

type vid = [
    `Alph_id of alphaalphanumeric_ident
  | `Symb_id of symbolic_ident (*tok*)
]

type lab = [
    `Alph_id of alphaalphanumeric_ident
  | `Symb_id of symbolic_ident (*tok*)
  | `Pat_dcab316 of pat_dcab316
]

type sigid = [ `Alph_id of alphaalphanumeric_ident ]

type scon_exp = scon

type scon_pat = scon

type tyvarseq = [
    `Tyvar of tyvar_ty
  | `LPAR_blank_blank_tyvar_rep_COMMA_tyvar_RPAR of (
        Token.t (* "(" *)
      * line_comment_explicit
      * line_comment_explicit
      * tyvar_ty
      * (Token.t (* "," *) * tyvar_ty) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

type longstrid = (
    (strid * Token.t (* "." *)) list (* zero or more *)
  * strid
)

type longtycon = (
    (strid * Token.t (* "." *)) list (* zero or more *)
  * tycon
)

type infix_dec = (
    Token.t (* "infix" *)
  * pat_213dc3e option
  * vid list (* one or more *)
)

type nonfix_dec = (Token.t (* "nonfix" *) * vid list (* one or more *))

type longvid = ((strid * Token.t (* "." *)) list (* zero or more *) * vid)

type infixr_dec = (
    Token.t (* "infixr" *)
  * pat_213dc3e option
  * vid list (* one or more *)
)

type sigid_sigexp = sigid

type typedesc_ = (tyvarseq option * tycon)

type strid_strexp = longstrid

type sharingtype_spec = (
    Token.t (* "sharing" *)
  * Token.t (* "type" *)
  * line_comment_explicit
  * line_comment_explicit
  * longtycon
  * Token.t (* "=" *)
  * longtycon
  * (Token.t (* "=" *) * longtycon) list (* zero or more *)
)

type datarepl_dec = (
    Token.t (* "datatype" *) * tycon * Token.t (* "=" *)
  * Token.t (* "datatype" *) * longtycon
)

type datarepl_spec = (
    Token.t (* "datatype" *) * tycon * Token.t (* "=" *)
  * Token.t (* "datatype" *) * longtycon
)

type atty = [
    `Tyvar_ty of tyvar_ty
  | `Record_ty of (
        Token.t (* "{" *)
      * tok_comma (*tok*) list (* one or more *) option
      * [
            `Opt_ellips_tyrow_opt_rep1_tok_comma of
              (
                  ellipsis_tyrow
                * tok_comma (*tok*) list (* one or more *) option
              )
                option
          | `Tyrow_rep_rep1_tok_comma_tyrow_opt_rep1_tok_comma_ellips_tyrow_opt_rep1_tok_comma of (
                tyrow
              * (tok_comma (*tok*) list (* one or more *) * tyrow)
                  list (* zero or more *)
              * (
                    tok_comma (*tok*) list (* one or more *)
                  * ellipsis_tyrow
                  * tok_comma (*tok*) list (* one or more *) option
                )
                  option
            )
        ]
      * Token.t (* "}" *)
    )
  | `Tycon_ty of (tyseq option * longtycon)
]

and ellipsis_tyrow = (Token.t (* "..." *) * Token.t (* ":" *) * ty)

and fn_ty = [
    `Fn_ty_ of (tuple_ty * Token.t (* "->" *) * ty)
  | `Tuple_ty of tuple_ty
]

and paren_ty = [
    `Paren_ty_ of (Token.t (* "(" *) * ty * Token.t (* ")" *))
  | `Atty of atty
]

and tuple_ty = [
    `Tuple_ty_ of (
        line_comment_explicit
      * line_comment_explicit
      * paren_ty
      * Token.t (* "*" *)
      * paren_ty
      * (Token.t (* "*" *) * paren_ty) list (* zero or more *)
    )
  | `Paren_ty of paren_ty
]

and ty = fn_ty

and tyrow = (lab * Token.t (* ":" *) * ty)

and tyseq = [
    `Atty of atty
  | `LPAR_blank_blank_ty_rep_COMMA_ty_RPAR of (
        Token.t (* "(" *)
      * line_comment_explicit
      * line_comment_explicit
      * ty
      * (Token.t (* "," *) * ty) list (* zero or more *)
      * Token.t (* ")" *)
    )
]

type vid_pat = (Token.t (* "op" *) option * longvid)

type typedesc = (
    line_comment_explicit
  * line_comment_explicit
  * typedesc_
  * (Token.t (* "and" *) * typedesc_) list (* zero or more *)
)

type open_dec = (Token.t (* "open" *) * strid_strexp list (* one or more *))

type sharing_spec = (
    Token.t (* "sharing" *)
  * line_comment_explicit
  * line_comment_explicit
  * strid_strexp
  * Token.t (* "=" *)
  * strid_strexp
  * (Token.t (* "=" *) * strid_strexp) list (* zero or more *)
)

type typbind_ = (tyvarseq option * tycon * Token.t (* "=" *) * ty)

type condesc_ = (vid * (Token.t (* "of" *) * ty) option)

type conbind_ = (
    Token.t (* "op" *) option
  * vid
  * (Token.t (* "of" *) * ty) option
)

type exdesc_ = (vid * (Token.t (* "of" *) * ty) option)

type valdesc_ = (vid * Token.t (* ":" *) * ty)

type anon_choice_line_comm_expl_b3a4c01 = [
    `Blank of line_comment_explicit
  | `Pat_rep_rep1_tok_comma_pat_opt_rep1_tok_comma of (
        pat
      * anon_rep_rep1_tok_comma_pat_097de3b
      * tok_comma (*tok*) list (* one or more *) option
    )
]

and anon_rep_rep1_tok_comma_pat_097de3b =
  (tok_comma (*tok*) list (* one or more *) * pat) list (* zero or more *)

and atpat = [
    `Semg_ellips of Token.t (* "..." *)
  | `Choice_wild_pat of [
        `Wild_pat of Token.t (* "_" *)
      | `Scon_pat of scon_pat
      | `Vid_pat of vid_pat
      | `Record_pat of record_pat
      | `Unit_pat of unit_pat
      | `Tuple_pat of tuple_pat
      | `List_pat of list_pat
      | `Vec_pat of vec_pat
      | `Paren_pat of paren_pat
    ]
]

and ellipsis_listpat = (Token.t (* "..." *) * Token.t (* "=" *) * pat)

and ellipsis_patrow = (
    Token.t (* "..." *)
  * (Token.t (* "=" *) * pat) option
)

and list_pat = (
    Token.t (* "[" *)
  * tok_comma (*tok*) list (* one or more *) option
  * [
        `Opt_ellips_list_opt_rep1_tok_comma of
          (
              ellipsis_listpat
            * tok_comma (*tok*) list (* one or more *) option
          )
            option
      | `Pat_rep_rep1_tok_comma_pat_opt_rep1_tok_comma_ellips_list_opt_rep1_tok_comma of (
            pat
          * anon_rep_rep1_tok_comma_pat_097de3b
          * (
                tok_comma (*tok*) list (* one or more *)
              * ellipsis_listpat
              * tok_comma (*tok*) list (* one or more *) option
            )
              option
        )
    ]
  * Token.t (* "]" *)
)

and paren_pat = (Token.t (* "(" *) * pat * Token.t (* ")" *))

and pat = [
    `Atpat of atpat
  | `App_pat of (atpat * atpat list (* one or more *))
  | `Typed_pat of (pat * Token.t (* ":" *) * ty)
  | `Conj_pat of (pat * Token.t (* "as" *) * pat)
  | `Disj_pat of (pat * Token.t (* "|" *) * pat)
]

and patrow = [
    `Patrow_ of (lab * Token.t (* "=" *) * pat)
  | `Labvar_patrow of (
        vid
      * (Token.t (* ":" *) * ty) option
      * (Token.t (* "as" *) * pat) option
    )
]

and record_pat = (
    Token.t (* "{" *)
  * tok_comma (*tok*) list (* one or more *) option
  * [
        `Opt_ellips_patrow_opt_rep1_tok_comma of
          (ellipsis_patrow * tok_comma (*tok*) list (* one or more *) option)
            option
      | `Patrow_rep_rep1_tok_comma_patrow_opt_rep1_tok_comma_ellips_patrow_opt_rep1_tok_comma of (
            patrow
          * (tok_comma (*tok*) list (* one or more *) * patrow)
              list (* zero or more *)
          * (
                tok_comma (*tok*) list (* one or more *)
              * ellipsis_patrow
              * tok_comma (*tok*) list (* one or more *) option
            )
              option
        )
    ]
  * Token.t (* "}" *)
)

and tuple_pat = (
    Token.t (* "(" *)
  * tok_comma (*tok*) list (* one or more *) option
  * anon_choice_line_comm_expl_b3a4c01
  * Token.t (* ")" *)
)

and vec_pat = (
    Token.t (* "#[" *)
  * tok_comma (*tok*) list (* one or more *) option
  * anon_choice_line_comm_expl_b3a4c01
  * Token.t (* ")" *)
)

type eqtype_spec = (Token.t (* "eqtype" *) * typedesc)

type typbind = (
    line_comment_explicit
  * line_comment_explicit
  * typbind_
  * (Token.t (* "and" *) * typbind_) list (* zero or more *)
)

type condesc = (
    tok_bar (*tok*) option
  * line_comment_explicit
  * line_comment_explicit
  * condesc_
  * (Token.t (* "|" *) * condesc_) list (* zero or more *)
)

type conbind = (
    tok_bar (*tok*) option
  * line_comment_explicit
  * line_comment_explicit
  * conbind_
  * (Token.t (* "|" *) * conbind_) list (* zero or more *)
)

type exbind_ = [
    `Opt_op_vid_opt_of_ty of conbind_
  | `Opt_op_vid_EQ_opt_op_long of (
        Token.t (* "op" *) option
      * vid
      * Token.t (* "=" *)
      * Token.t (* "op" *) option
      * longvid
    )
]

type exdesc = (
    line_comment_explicit
  * line_comment_explicit
  * exdesc_
  * (Token.t (* "and" *) * exdesc_) list (* zero or more *)
)

type valdesc = (
    line_comment_explicit
  * line_comment_explicit
  * valdesc_
  * (Token.t (* "and" *) * valdesc_) list (* zero or more *)
)

type type_spec = (
    Token.t (* "type" *)
  * [ `Type of typedesc | `Typb of typbind ]
)

type type_dec = (Token.t (* "type" *) * typbind)

type datdesc_ = (tyvarseq option * tycon * Token.t (* "=" *) * condesc)

type datbind_ = (tyvarseq option * tycon * Token.t (* "=" *) * conbind)

type exbind = (
    line_comment_explicit
  * line_comment_explicit
  * exbind_
  * (Token.t (* "and" *) * exbind_) list (* zero or more *)
)

type exception_spec = (Token.t (* "exception" *) * exdesc)

type val_spec = (Token.t (* "val" *) * valdesc)

type datdesc = (
    line_comment_explicit
  * line_comment_explicit
  * datdesc_
  * (Token.t (* "and" *) * datdesc_) list (* zero or more *)
)

type datbind = (
    line_comment_explicit
  * line_comment_explicit
  * datbind_
  * (Token.t (* "and" *) * datbind_) list (* zero or more *)
)

type exception_dec = (Token.t (* "exception" *) * exbind)

type datatype_spec = (
    Token.t (* "datatype" *)
  * datdesc
  * (Token.t (* "withtype" *) * typbind) option
)

type datatype_dec = (
    Token.t (* "datatype" *)
  * datbind
  * (Token.t (* "withtype" *) * typbind) option
)

type anon_choice_SEMI_aa47496 = [
    `SEMI of Token.t (* ";" *)
  | `Spec of spec
]

and include_spec = (
    Token.t (* "include" *)
  * [
        `Sigexp of sigexp
      | `Sigid_rep1_sigid of (
            sigid_sigexp
          * sigid_sigexp list (* one or more *)
        )
    ]
)

and sigexp = [
    `Sig_sigexp of (
        Token.t (* "sig" *)
      * anon_choice_SEMI_aa47496 list (* zero or more *)
      * Token.t (* "end" *)
    )
  | `Sigid_sigexp of sigid_sigexp
  | `Wher_sigexp of (
        sigexp
      * Token.t (* "where" *)
      * line_comment_explicit
      * line_comment_explicit
      * Token.t (* "type" *)
      * tyvarseq option
      * longtycon
      * Token.t (* "=" *)
      * ty
      * (
            Token.t (* "and" *)
          * Token.t (* "type" *)
          * tyvarseq option
          * longtycon
          * Token.t (* "=" *)
          * ty
        )
          list (* zero or more *)
    )
]

and spec = [
    `Semg_ellips of Token.t (* "..." *)
  | `Choice_val_spec of [
        `Val_spec of val_spec
      | `Type_spec of type_spec
      | `Eqtype_spec of eqtype_spec
      | `Data_spec_d5fa734 of datatype_spec
      | `Data_spec_86dd5a7 of datarepl_spec
      | `Exc_spec of exception_spec
      | `Stru_spec of structure_spec
      | `Incl_spec of include_spec
      | `Shar_spec_5735bb3 of sharingtype_spec
      | `Shar_spec_a6177ec of sharing_spec
    ]
]

and strdesc = (
    line_comment_explicit
  * line_comment_explicit
  * strdesc_
  * (Token.t (* "and" *) * strdesc_) list (* zero or more *)
)

and strdesc_ = (strid * Token.t (* ":" *) * sigexp)

and structure_spec = (Token.t (* "structure" *) * strdesc)

type abstype_dec = (
    Token.t (* "abstype" *)
  * datbind
  * (Token.t (* "withtype" *) * typbind) option
  * Token.t (* "with" *)
  * anon_choice_SEMI_d1f1a0a list (* zero or more *)
  * Token.t (* "end" *)
)

and anon_choice_SEMI_d1f1a0a = [ `SEMI of Token.t (* ";" *) | `Dec of dec ]

and anon_choice_line_comm_expl_8d74692 = [
    `Blank of line_comment_explicit
  | `Exp_rep_rep1_tok_comma_exp_opt_rep1_tok_comma of (
        exp
      * anon_rep_rep1_tok_comma_exp_3e034b9
      * tok_comma (*tok*) list (* one or more *) option
    )
]

and anon_rep_rep1_tok_comma_exp_3e034b9 =
  (tok_comma (*tok*) list (* one or more *) * exp) list (* zero or more *)

and anon_rep_rep1_tok_semi_exp_116885f =
  (tok_semi (*tok*) list (* one or more *) * exp) list (* zero or more *)

and atexp = [
    `Scon_exp of scon_exp
  | `Vid_exp of (Token.t (* "op" *) option * longvid)
  | `Record_exp of (
        Token.t (* "{" *)
      * tok_comma (*tok*) list (* one or more *) option
      * [
            `Opt_ellips_exprow_opt_rep1_tok_comma of
              (
                  ellipsis_exprow
                * tok_comma (*tok*) list (* one or more *) option
              )
                option
          | `Exprow_rep_rep1_tok_comma_exprow_opt_rep1_tok_comma_ellips_exprow_opt_rep1_tok_comma of (
                exprow
              * (tok_comma (*tok*) list (* one or more *) * exprow)
                  list (* zero or more *)
              * (
                    tok_comma (*tok*) list (* one or more *)
                  * ellipsis_exprow
                  * tok_comma (*tok*) list (* one or more *) option
                )
                  option
            )
        ]
      * Token.t (* "}" *)
    )
  | `Reco_exp of (Token.t (* "#" *) * lab)
  | `Unit_exp of (Token.t (* "(" *) * Token.t (* ")" *))
  | `Tuple_exp of (
        Token.t (* "(" *)
      * tok_comma (*tok*) list (* one or more *) option
      * anon_choice_line_comm_expl_8d74692
      * Token.t (* ")" *)
    )
  | `List_exp of (
        Token.t (* "[" *)
      * tok_comma (*tok*) list (* one or more *) option
      * [
            `Opt_ellips_list_opt_rep1_tok_comma of
              (
                  ellipsis_listexp
                * tok_comma (*tok*) list (* one or more *) option
              )
                option
          | `Exp_rep_rep1_tok_comma_exp_opt_rep1_tok_comma_ellips_list_opt_rep1_tok_comma of (
                exp
              * anon_rep_rep1_tok_comma_exp_3e034b9
              * (
                    tok_comma (*tok*) list (* one or more *)
                  * ellipsis_listexp
                  * tok_comma (*tok*) list (* one or more *) option
                )
                  option
            )
        ]
      * Token.t (* "]" *)
    )
  | `Vec_exp of (
        Token.t (* "#[" *)
      * tok_comma (*tok*) list (* one or more *) option
      * anon_choice_line_comm_expl_8d74692
      * Token.t (* "]" *)
    )
  | `Seq_exp of (
        Token.t (* "(" *)
      * tok_semi (*tok*) list (* one or more *) option
      * [
            `Blank of line_comment_explicit
          | `Exp_rep_rep1_tok_semi_exp_opt_rep1_tok_semi of (
                exp
              * anon_rep_rep1_tok_semi_exp_116885f
              * tok_semi (*tok*) list (* one or more *) option
            )
        ]
      * Token.t (* ")" *)
    )
  | `Let_exp of (
        Token.t (* "let" *)
      * anon_choice_SEMI_d1f1a0a list (* zero or more *)
      * Token.t (* "in" *)
      * tok_semi (*tok*) list (* one or more *) option
      * line_comment_explicit
      * exp
      * anon_rep_rep1_tok_semi_exp_116885f
      * tok_semi (*tok*) list (* one or more *) option
      * Token.t (* "end" *)
    )
  | `Paren_exp of (Token.t (* "(" *) * exp * Token.t (* ")" *))
]

and dec = [
    `Dec_no_local of dec_no_local
  | `Local_dec of (
        Token.t (* "local" *)
      * anon_choice_SEMI_d1f1a0a list (* zero or more *)
      * Token.t (* "in" *)
      * anon_choice_SEMI_d1f1a0a list (* zero or more *)
      * Token.t (* "end" *)
    )
]

and dec_no_local = [
    `Semg_ellips of Token.t (* "..." *)
  | `Choice_do_dec of [
        `Do_dec of do_dec
      | `Val_dec of val_dec
      | `Fun_dec of fun_dec
      | `Type_dec of type_dec
      | `Data_dec_c9b9a7a of datatype_dec
      | `Data_dec_4d86b7f of datarepl_dec
      | `Abst_dec of abstype_dec
      | `Exc_dec of exception_dec
      | `Open_dec of open_dec
      | `Infix_dec of infix_dec
      | `Infixr_dec of infixr_dec
      | `Nonfix_dec of nonfix_dec
    ]
]

and do_dec = (Token.t (* "do" *) * exp)

and ellipsis_exprow = (Token.t (* "..." *) * Token.t (* "=" *) * exp)

and ellipsis_listexp = (Token.t (* "..." *) * Token.t (* "=" *) * exp)

and exp = [
    `Atexp of atexp
  | `App_exp of (atexp * atexp list (* one or more *))
  | `Typed_exp of (exp * Token.t (* ":" *) * ty)
  | `Conj_exp of (exp * Token.t (* "andalso" *) * exp)
  | `Disj_exp of (exp * Token.t (* "orelse" *) * exp)
  | `Handle_exp of (exp * Token.t (* "handle" *) * match_)
  | `Raise_exp of (Token.t (* "raise" *) * exp)
  | `Cond_exp of (
        Token.t (* "if" *)
      * exp
      * Token.t (* "then" *)
      * exp
      * (Token.t (* "else" *) * exp) option
    )
  | `Iter_exp of (Token.t (* "while" *) * exp * Token.t (* "do" *) * exp)
  | `Case_exp of (Token.t (* "case" *) * exp * Token.t (* "of" *) * match_)
  | `Fn_exp of (Token.t (* "fn" *) * match_)
]

and exprow = [
    `Exprow_ of (lab * Token.t (* "=" *) * exp)
  | `Labvar_exprow of (vid * (Token.t (* ":" *) * ty) option)
]

and fmatch = (
    tok_bar (*tok*) option
  * line_comment_explicit
  * line_comment_explicit
  * fmrule
  * (Token.t (* "|" *) * fmrule) list (* zero or more *)
)

and fmrule = (
    [
        `Opt_op_vid_rep1_atpat of (
            Token.t (* "op" *) option
          * vid
          * atpat list (* one or more *)
        )
      | `LPAR_atpat_vid_atpat_RPAR_rep_atpat of (
            Token.t (* "(" *)
          * atpat
          * vid
          * atpat
          * Token.t (* ")" *)
          * atpat list (* zero or more *)
        )
      | `Atpat_vid_atpat of (atpat * vid * atpat)
    ]
  * (Token.t (* ":" *) * ty) option
  * Token.t (* "=" *)
  * exp
)

and fun_dec = (Token.t (* "fun" *) * tyvarseq option * fvalbind)

and fvalbind = (
    line_comment_explicit
  * line_comment_explicit
  * fvalbind_
  * (Token.t (* "and" *) * fvalbind_) list (* zero or more *)
)

and fvalbind_ = fmatch

and match_ = (
    tok_bar (*tok*) option
  * line_comment_explicit
  * line_comment_explicit
  * mrule
  * (Token.t (* "|" *) * mrule) list (* zero or more *)
)

and mrule = [
    `Semg_ellips of Token.t (* "..." *)
  | `Pat_EQGT_exp of (pat * Token.t (* "=>" *) * exp)
]

and val_dec = (
    Token.t (* "val" *)
  * Token.t (* "rec" *) option
  * tyvarseq option
  * valbind
)

and valbind = (
    line_comment_explicit
  * line_comment_explicit
  * valbind_
  * (Token.t (* "and" *) * valbind_) list (* zero or more *)
)

and valbind_ = (pat * Token.t (* "=" *) * exp)

type sigbind_ = (sigid_sigexp * Token.t (* "=" *) * sigexp)

type anon_choice_SEMI_338101e = [
    `SEMI of Token.t (* ";" *)
  | `Strdec of strdec
]

and strbind = (
    line_comment_explicit
  * line_comment_explicit
  * strbind_
  * (Token.t (* "and" *) * strbind_) list (* zero or more *)
)

and strbind_ = (
    strid
  * (anon_choice_COLON_49dafc4 * sigexp) option
  * Token.t (* "=" *)
  * strexp
)

and strdec = [
    `Dec_no_local of dec_no_local
  | `Stru_strdec of (Token.t (* "structure" *) * strbind)
  | `Local_strdec of (
        Token.t (* "local" *)
      * anon_choice_SEMI_338101e list (* zero or more *)
      * Token.t (* "in" *)
      * anon_choice_SEMI_338101e list (* zero or more *)
      * Token.t (* "end" *)
    )
]

and strexp = [
    `Struct_strexp of (
        Token.t (* "struct" *)
      * anon_choice_SEMI_338101e list (* zero or more *)
      * Token.t (* "end" *)
    )
  | `Strid_strexp of strid_strexp
  | `Constr_strexp of (strexp * anon_choice_COLON_49dafc4 * sigexp)
  | `Fctapp_strexp of (
        fctid
      * Token.t (* "(" *)
      * [
            `Strexp of strexp
          | `Rep_choice_SEMI of
              anon_choice_SEMI_338101e list (* zero or more *)
        ]
      * Token.t (* ")" *)
    )
  | `Let_strexp of (
        Token.t (* "let" *)
      * anon_choice_SEMI_338101e list (* zero or more *)
      * Token.t (* "in" *)
      * strexp
      * Token.t (* "end" *)
    )
]

type sigbind = (
    line_comment_explicit
  * line_comment_explicit
  * sigbind_
  * (Token.t (* "and" *) * sigbind_) list (* zero or more *)
)

type fctbind_ = (
    fctid
  * Token.t (* "(" *)
  * [
        `Strid_COLON_sigexp of strdesc_
      | `Rep_choice_SEMI of anon_choice_SEMI_aa47496 list (* zero or more *)
    ]
  * Token.t (* ")" *)
  * (anon_choice_COLON_49dafc4 * sigexp) option
  * Token.t (* "=" *)
  * strexp
)

type fctbind = (
    line_comment_explicit
  * line_comment_explicit
  * fctbind_
  * (Token.t (* "and" *) * fctbind_) list (* zero or more *)
)

type sigdec = [ `Sign_sigdec of (Token.t (* "signature" *) * sigbind) ]

type topdec = [
    `Strdec of strdec
  | `Sigdec of sigdec
  | `Fctdec of (Token.t (* "functor" *) * fctbind)
]

type program = [
  `Rectype of (
      [ `Rep1_topdec of topdec list (* one or more *) | `Exp of exp ]
    * (Token.t (* ";" *) * source_file) option
  )
]

and source_file = program option

type wildcard_pat (* inlined *) = Token.t (* "_" *)

type semgrep_ellipsis (* inlined *) = Token.t (* "..." *)

type ident (* inlined *) = Token.t

type unit_exp (* inlined *) = (Token.t (* "(" *) * Token.t (* ")" *))

type dummy_alias1 (* inlined *) = block_comment (*tok*)

type comment (* inlined *) = [
    `Blk_comm_expl of block_comment_explicit (*tok*)
  | `Line_comm_expl of line_comment_explicit (*tok*)
]

type dummy_alias0 (* inlined *) = line_comment (*tok*)

type recordsel_exp (* inlined *) = (Token.t (* "#" *) * lab)

type fn_ty_ (* inlined *) = (tuple_ty * Token.t (* "->" *) * ty)

type paren_ty_ (* inlined *) = (Token.t (* "(" *) * ty * Token.t (* ")" *))

type record_ty (* inlined *) = (
    Token.t (* "{" *)
  * tok_comma (*tok*) list (* one or more *) option
  * [
        `Opt_ellips_tyrow_opt_rep1_tok_comma of
          (ellipsis_tyrow * tok_comma (*tok*) list (* one or more *) option)
            option
      | `Tyrow_rep_rep1_tok_comma_tyrow_opt_rep1_tok_comma_ellips_tyrow_opt_rep1_tok_comma of (
            tyrow
          * (tok_comma (*tok*) list (* one or more *) * tyrow)
              list (* zero or more *)
          * (
                tok_comma (*tok*) list (* one or more *)
              * ellipsis_tyrow
              * tok_comma (*tok*) list (* one or more *) option
            )
              option
        )
    ]
  * Token.t (* "}" *)
)

type tuple_ty_ (* inlined *) = (
    line_comment_explicit
  * line_comment_explicit
  * paren_ty
  * Token.t (* "*" *)
  * paren_ty
  * (Token.t (* "*" *) * paren_ty) list (* zero or more *)
)

type tycon_ty (* inlined *) = (tyseq option * longtycon)

type vid_exp (* inlined *) = (Token.t (* "op" *) option * longvid)

type labvar_exprow (* inlined *) = (vid * (Token.t (* ":" *) * ty) option)

type anon_pat_rep_rep1_tok_comma_pat_opt_rep1_tok_comma_de7bafe (* inlined *) = (
    pat
  * anon_rep_rep1_tok_comma_pat_097de3b
  * tok_comma (*tok*) list (* one or more *) option
)

type app_pat (* inlined *) = (atpat * atpat list (* one or more *))

type conj_pat (* inlined *) = (pat * Token.t (* "as" *) * pat)

type disj_pat (* inlined *) = (pat * Token.t (* "|" *) * pat)

type labvar_patrow (* inlined *) = (
    vid
  * (Token.t (* ":" *) * ty) option
  * (Token.t (* "as" *) * pat) option
)

type patrow_ (* inlined *) = (lab * Token.t (* "=" *) * pat)

type typed_pat (* inlined *) = (pat * Token.t (* ":" *) * ty)

type as_pat (* inlined *) = (
    Token.t (* "op" *) option
  * vid
  * (Token.t (* ":" *) * ty) option
  * Token.t (* "as" *)
  * pat
)

type sig_sigexp (* inlined *) = (
    Token.t (* "sig" *)
  * anon_choice_SEMI_aa47496 list (* zero or more *)
  * Token.t (* "end" *)
)

type wheretype_sigexp (* inlined *) = (
    sigexp
  * Token.t (* "where" *)
  * line_comment_explicit
  * line_comment_explicit
  * Token.t (* "type" *)
  * tyvarseq option
  * longtycon
  * Token.t (* "=" *)
  * ty
  * (
        Token.t (* "and" *)
      * Token.t (* "type" *)
      * tyvarseq option
      * longtycon
      * Token.t (* "=" *)
      * ty
    )
      list (* zero or more *)
)

type anon_exp_rep_rep1_tok_comma_exp_opt_rep1_tok_comma_448bcd9 (* inlined *) = (
    exp
  * anon_rep_rep1_tok_comma_exp_3e034b9
  * tok_comma (*tok*) list (* one or more *) option
)

type app_exp (* inlined *) = (atexp * atexp list (* one or more *))

type case_exp (* inlined *) = (
    Token.t (* "case" *) * exp * Token.t (* "of" *) * match_
)

type cond_exp (* inlined *) = (
    Token.t (* "if" *)
  * exp
  * Token.t (* "then" *)
  * exp
  * (Token.t (* "else" *) * exp) option
)

type conj_exp (* inlined *) = (exp * Token.t (* "andalso" *) * exp)

type disj_exp (* inlined *) = (exp * Token.t (* "orelse" *) * exp)

type exprow_ (* inlined *) = (lab * Token.t (* "=" *) * exp)

type fn_exp (* inlined *) = (Token.t (* "fn" *) * match_)

type handle_exp (* inlined *) = (exp * Token.t (* "handle" *) * match_)

type iter_exp (* inlined *) = (
    Token.t (* "while" *) * exp * Token.t (* "do" *) * exp
)

type let_exp (* inlined *) = (
    Token.t (* "let" *)
  * anon_choice_SEMI_d1f1a0a list (* zero or more *)
  * Token.t (* "in" *)
  * tok_semi (*tok*) list (* one or more *) option
  * line_comment_explicit
  * exp
  * anon_rep_rep1_tok_semi_exp_116885f
  * tok_semi (*tok*) list (* one or more *) option
  * Token.t (* "end" *)
)

type list_exp (* inlined *) = (
    Token.t (* "[" *)
  * tok_comma (*tok*) list (* one or more *) option
  * [
        `Opt_ellips_list_opt_rep1_tok_comma of
          (
              ellipsis_listexp
            * tok_comma (*tok*) list (* one or more *) option
          )
            option
      | `Exp_rep_rep1_tok_comma_exp_opt_rep1_tok_comma_ellips_list_opt_rep1_tok_comma of (
            exp
          * anon_rep_rep1_tok_comma_exp_3e034b9
          * (
                tok_comma (*tok*) list (* one or more *)
              * ellipsis_listexp
              * tok_comma (*tok*) list (* one or more *) option
            )
              option
        )
    ]
  * Token.t (* "]" *)
)

type local_dec (* inlined *) = (
    Token.t (* "local" *)
  * anon_choice_SEMI_d1f1a0a list (* zero or more *)
  * Token.t (* "in" *)
  * anon_choice_SEMI_d1f1a0a list (* zero or more *)
  * Token.t (* "end" *)
)

type paren_exp (* inlined *) = (Token.t (* "(" *) * exp * Token.t (* ")" *))

type raise_exp (* inlined *) = (Token.t (* "raise" *) * exp)

type record_exp (* inlined *) = (
    Token.t (* "{" *)
  * tok_comma (*tok*) list (* one or more *) option
  * [
        `Opt_ellips_exprow_opt_rep1_tok_comma of
          (ellipsis_exprow * tok_comma (*tok*) list (* one or more *) option)
            option
      | `Exprow_rep_rep1_tok_comma_exprow_opt_rep1_tok_comma_ellips_exprow_opt_rep1_tok_comma of (
            exprow
          * (tok_comma (*tok*) list (* one or more *) * exprow)
              list (* zero or more *)
          * (
                tok_comma (*tok*) list (* one or more *)
              * ellipsis_exprow
              * tok_comma (*tok*) list (* one or more *) option
            )
              option
        )
    ]
  * Token.t (* "}" *)
)

type sequence_exp (* inlined *) = (
    Token.t (* "(" *)
  * tok_semi (*tok*) list (* one or more *) option
  * [
        `Blank of line_comment_explicit
      | `Exp_rep_rep1_tok_semi_exp_opt_rep1_tok_semi of (
            exp
          * anon_rep_rep1_tok_semi_exp_116885f
          * tok_semi (*tok*) list (* one or more *) option
        )
    ]
  * Token.t (* ")" *)
)

type tuple_exp (* inlined *) = (
    Token.t (* "(" *)
  * tok_comma (*tok*) list (* one or more *) option
  * anon_choice_line_comm_expl_8d74692
  * Token.t (* ")" *)
)

type typed_exp (* inlined *) = (exp * Token.t (* ":" *) * ty)

type vec_exp (* inlined *) = (
    Token.t (* "#[" *)
  * tok_comma (*tok*) list (* one or more *) option
  * anon_choice_line_comm_expl_8d74692
  * Token.t (* "]" *)
)

type constr_strexp (* inlined *) = (
    strexp * anon_choice_COLON_49dafc4 * sigexp
)

type fctapp_strexp (* inlined *) = (
    fctid
  * Token.t (* "(" *)
  * [
        `Strexp of strexp
      | `Rep_choice_SEMI of anon_choice_SEMI_338101e list (* zero or more *)
    ]
  * Token.t (* ")" *)
)

type let_strexp (* inlined *) = (
    Token.t (* "let" *)
  * anon_choice_SEMI_338101e list (* zero or more *)
  * Token.t (* "in" *)
  * strexp
  * Token.t (* "end" *)
)

type local_strdec (* inlined *) = (
    Token.t (* "local" *)
  * anon_choice_SEMI_338101e list (* zero or more *)
  * Token.t (* "in" *)
  * anon_choice_SEMI_338101e list (* zero or more *)
  * Token.t (* "end" *)
)

type struct_strexp (* inlined *) = (
    Token.t (* "struct" *)
  * anon_choice_SEMI_338101e list (* zero or more *)
  * Token.t (* "end" *)
)

type structure_strdec (* inlined *) = (Token.t (* "structure" *) * strbind)

type signature_sigdec (* inlined *) = (Token.t (* "signature" *) * sigbind)

type fctdec (* inlined *) = (Token.t (* "functor" *) * fctbind)

type extra = [
    `Block_comment of Loc.t * block_comment
  | `Line_comment of Loc.t * line_comment
]

type extras = extra list
